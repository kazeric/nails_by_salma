'use strict';

var stega = require('@vercel/stega');
var strapiUtils = require('@strapi/utils');

const ENCODABLE_TYPES = [
    'string',
    'text',
    'richtext',
    'biginteger',
    'date',
    'time',
    'datetime',
    'timestamp',
    'boolean',
    'enumeration',
    'json',
    'media',
    'email',
    'password'
];
// TODO: use a centralized store for these fields that would be shared with the CM and CTB
const EXCLUDED_FIELDS = [
    'id',
    'documentId',
    'locale',
    'localizations',
    'created_by',
    'updated_by',
    'created_at',
    'updated_at',
    'publishedAt'
];
const isObject = (value)=>{
    return typeof value === 'object' && value !== null;
};
const createContentSourceMapsService = (strapi)=>{
    return {
        encodeField (text, key) {
            const res = stega.vercelStegaCombine(text, {
                // TODO: smarter metadata than just the key
                key
            });
            return res;
        },
        async encodeEntry ({ data, schema }) {
            if (!isObject(data) || data === undefined) {
                return data;
            }
            return strapiUtils.traverseEntity(({ key, value, attribute }, { set })=>{
                if (!attribute || EXCLUDED_FIELDS.includes(key)) {
                    return;
                }
                if (ENCODABLE_TYPES.includes(attribute.type) && typeof value === 'string') {
                    set(key, this.encodeField(value, key));
                }
            }, {
                schema,
                getModel: (uid)=>strapi.getModel(uid)
            }, data);
        },
        async encodeSourceMaps ({ data, schema }) {
            try {
                if (Array.isArray(data)) {
                    return await Promise.all(data.map((item)=>this.encodeSourceMaps({
                            data: item,
                            schema
                        })));
                }
                if (!isObject(data)) {
                    return data;
                }
                return await this.encodeEntry({
                    data,
                    schema
                });
            } catch (error) {
                strapi.log.error('Error encoding source maps:', error);
                return data;
            }
        }
    };
};

exports.createContentSourceMapsService = createContentSourceMapsService;
//# sourceMappingURL=content-source-maps.js.map
